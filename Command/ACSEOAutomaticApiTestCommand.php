<?php

namespace ACSEO\Bundle\BehatGeneratorBundle\Command;

use ACSEO\Bundle\BehatGeneratorBundle\Util\GherkinWriter as Writer;
use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Filesystem\Filesystem;

/**
 * ACSEOAutomaticApiTestCommand creates automatic Behat features for api.
 */
class ACSEOAutomaticApiTestCommand extends ContainerAwareCommand
{
    protected $writer;

    /**
     * {@inheritdoc}
     */
    protected function configure()
    {
        $this
            ->setName('acseo:automatic-api-test')
            ->setDescription('Generate automatic tests for api')
        ;
    }

    /**
     * {@inheritdoc}
     *
     */
    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $this->io = new SymfonyStyle($input, $output);
        $this->writer = new Writer();

        $autoFeatureApiPath = $this->checkFolderStructure();

        $apiData = $this->getContainer()->get('nelmio_api_doc.extractor.api_doc_extractor')->all();
        $aggregates = $this->aggregate($apiData);

        foreach ($aggregates as $name => $aggregate) {
            if ($aggregate['CREATE'] !== null) {
                $test = $this->generateTest($name, $aggregate);
                file_put_contents($autoFeatureApiPath .'/'. $name .'.feature', $test);
                $this->io->success('Writing feature test for api resource: '. $name);
            } else {
                $this->io->warning('No route exists for creating '. $name .' in the api. No test created.');
            }
        }
    }

    /**
     * Aggregate api route by resource and actions.
     *
     * @param  array  $apiData
     * @return array
     */
    protected function aggregate(array $apiData = array())
    {
        if (count($apiData) === 0) {
            throw new \Exception('No data fetched from Nelmio api doc.');
        }

        $aggregate = array();
        foreach ($apiData as $data) {
            $data = $data['annotation'];
            $name = $data->getSection();
            if (!isset($aggregate[$name])) {
                $aggregate[$name] = array(
                    'CREATE' => null,
                    'GET_SINGLE' => null,
                    'GET_ALL' => null,
                    'EDIT' => null,
                    'DELETE' => null
                );
            }
            switch ($data->getMethod()) {
                case 'POST':
                    if ($this->isREST('CREATE', $data)) {
                        $aggregate[$name]['CREATE'] = $data;
                    }
                    break;
                case 'GET':
                    if (strpos($data->getResource(), '{id}') !== false) {
                        if ($this->isREST('GET_SINGLE', $data)) {
                            $aggregate[$name]['GET_SINGLE'] = $data;
                        }
                    } else {
                        if ($this->isREST('GET_ALL', $data)) {
                            $aggregate[$name]['GET_ALL'] = $data;
                        }
                    }
                    break;
                case 'PUT':
                    if ($this->isREST('EDIT', $data)) {
                        $aggregate[$data->getSection()]['EDIT'] = $data;
                    }
                    break;
                case 'DELETE':
                    if ($this->isREST('DELETE', $data)) {
                        $aggregate[$data->getSection()]['DELETE'] = $data;
                    }
                    break;
            }
        }

        return $aggregate;
    }

    /**
     * Generate test for an api resource.
     *
     * @param  string $name      is the name of the resource
     * @param  array  $aggregate is an aggregation of all rest routes of the api for the resource
     * @return string            is the test as string to save in a file
     */
    protected function generateTest($name, $aggregate)
    {
        $this->writer
            ->addComment('This test is automatically generated by ACSEOAutomaticApiTestCommand')
            ->addComment('Feel free to edit any part to adapt to specific situations')
            ->emptyLine()
            ->addLine('Feature: Automatic test for api resource '. $name)
            ->emptyLine()
                ->subLine('@createSchema')
        ;

        foreach ($aggregate as $action => $data) {
            if ($data !== null) {

                $this->writer
                    ->emptyLine()
                    ->addLine('Scenario: ' .  str_replace('_', ' ', $action) . ' ' . $name, 1)
                ;

                $method = $data->getMethod();

                $url = $data->getResource();
                if (strpos($url, '{id}') !== false) {
                    $url = str_replace('{id}', '1', $url);
                }

                // Base request
                $request = 'When I send a "'. $method .'" request to "'. $url .'"';

                // If authentication needed
                if (true === $data->getAuthentication()) {
                    $request = 'When I send an authenticated "'. $method .'" request to "'. $url .'"';
                }

                // If parameters expected
                if (in_array($data->getMethod(), ['POST', 'PUT']) && count($data->getParameters()) > 0) {
                    $params = $this->generateFakeParams($data);
                    $this->writer
                        ->subLine($request.' with body:')
                        ->addJson($params)
                    ;

                } else {
                    $this->writer->subLine($request);
                }

                $this->writer
                    ->addLine('Then I should get a success code')
                    ->addLine('Then the url should match "'. $url .'"')
                ;
            }
        }

        return $this->writer->generateOutput();
    }

    /**
     * Check if needed folders are there, create them if not and return the path to the final directory.
     * @return string
     */
    protected function checkFolderStructure()
    {
        $fs = new Filesystem();
        $featurePath = $this->getContainer()->get('kernel')->getRootDir()."/../features";
        if(!$fs->exists($featurePath)) {
            throw new \Exception("The feature folder does not exist in this project");
        }
        $autoFeaturePath = $this->getContainer()->get('kernel')->getRootDir()."/../features/automatic";
        if(!$fs->exists($autoFeaturePath)) {
            $fs->mkdir($autoFeaturePath);
            $this->io->note("Creating the automatic folder in ".$featurePath);
        }
        $autoFeatureApiPath = $this->getContainer()->get('kernel')->getRootDir()."/../features/automatic/api";
        if(!$fs->exists($autoFeatureApiPath)) {
            $fs->mkdir($autoFeatureApiPath);
            $this->io->note("Creating the automatic folder in ".$autoFeaturePath);
        }

        return $autoFeatureApiPath;
    }

    /**
     * Generate fake parameters to send depending on parameters expected by the api.
     *
     * @param  array $data
     * @return array
     */
    protected function generateFakeParams($data)
    {
        $params = array();

        // Fetch asserts bound to entity
        $asserts = array();
        $entityNamespace = explode(':', $data->getOutput());
        if (isset($entityNamespace[1])) {
            $entityNamespace = $entityNamespace[1];
        }
        if ($entityNamespace) {
            if ($entityNamespace[0] !== '\\') {
                $entityNamespace = '\\' . $entityNamespace;
            }
            $asserts = $this->getAsserts($entityNamespace);
        }

        $faker = \Faker\Factory::create('fr_FR');

        foreach ($data->getParameters() as $name => $details) {

            // Make it fit to Faker

            $attribute = $name;

            // Integer
            if ('integer' === $details['dataType']) {
                $attribute = 'randomDigit';
            // Float
            } elseif ('float' === $details['dataType']) {
                $attribute = 'randomFloat';
            // String
            } elseif ('string' === $details['dataType']) {
                // Post code
                if (false !== stripos($name, 'zipcode')) {
                    $attribute = 'postcode';
                // Phone
                } elseif (false !== stripos($name, 'phone')) {
                    $attribute = 'phoneNumber';
                // Address
                } elseif (false !== stripos($name, 'location')) {
                    $attribute = 'address';
                // Url, domain name
                } elseif (false !== stripos($name, 'url') || false !== stripos($name, 'website')) {
                    $attribute = 'domainName';
                // Files (disabled for now - TODO)
                } elseif (false !== stripos($name, 'file') || false !== stripos($name, 'attachment')) {
                    $attribute = null;
                }
                // Default value
                try {
                    $faker->$attribute;
                } catch (\Exception $e) {
                    $attribute = 'word';
                }
            // Datetime
            } elseif ('datetime' === $details['dataType']) {
                $attribute = 'iso8601';
            // Id, or collection of ids - Disabled
            } elseif (false !== stripos($details['dataType'], 'IRI')) {
                $attribute = null;
            }

            // Try to get a value
            try {
                if ($attribute) {
                    $params[$name] = $faker->$attribute;
                } else {
                    throw new \Exception('Nothing to process');
                }
                // Handle asserts (text length only for now)
                if (isset($asserts[$name])) {
                    // If try to generate text
                    if ($details['dataType'] === 'string') {
                        // Fit to assert bas on length
                        if (isset($asserts[$name]['Length'])) {
                            // Minimum
                            if (isset($asserts[$name]['Length']['min'])) {
                                while (strlen($params[$name]) < $asserts[$name]['Length']['min']) {
                                    $params[$name] = $faker->$details['dataType'];
                                }
                            }
                            // Maximum
                            if (isset($asserts[$name]['Length']['max'])) {
                                if (strlen($params[$name]) > $asserts[$name]['Length']['max']) {
                                    $params[$name] = $faker->realText($asserts[$name]['Length']['max']);
                                }
                            }
                        }
                    }
                }

            } catch (\Exception $e) {
                try {
                    if ($attribute) {
                        $params[$name] = $faker->$details['dataType'];
                    } else {
                        throw new \Exception('Nothing to process');
                    }
                } catch (\Exception $e) {
                    $params[$name] = null;
                    if (true === $details['required']) {
                        $this->io->warning('Required parameter "'. $name .'" of type "'. $details['dataType'] .'" for resource "'. $data->getResource() .'" could not be generated by faking values. It has been set to null.');
                    }
                }
            }
        }

        return $params;
    }

    /**
     * Check if a route is REST.
     *
     * @param  string  $action
     * @param  [type]  $data
     * @return boolean
     */
    protected function isREST($action, $data)
    {
        $expected = '/'. $this->camelToSnakeCase($data->getSection()) .'s';

        switch ($action) {
            // Collection operations
            case 'CREATE':
            case 'GET_ALL':
                break;
            // Item operations
            case 'GET_SINGLE':
            case 'EDIT':
            case 'DELETE':
                $expected .= '/{id}';
                break;

            default:
                return false;
        }

        return $data->getResource() === $expected;
    }

    /**
     * Turn camelCase into snake_case.
     *
     * @param  string $input
     * @return string
     */
    protected function camelToSnakeCase($input)
    {
        preg_match_all('!([A-Z][A-Z0-9]*(?=$|[A-Z][a-z0-9])|[A-Za-z][a-z0-9]+)!', $input, $matches);
        $ret = $matches[0];
        foreach ($ret as &$match) {
            $match = $match == strtoupper($match) ? strtolower($match) : lcfirst($match);
        }

        return implode('_', $ret);
    }

    /**
     * Get asserts attached to an entity.
     *
     * @param  string $namespace
     * @return array
     */
    protected function getAsserts($namespace)
    {
        $validations = [];
        $validator = $this->getContainer()->get("validator");
        $metadata = $validator->getMetadataFor(new $namespace());
        $constrainedProperties = $metadata->getConstrainedProperties();
        foreach ($constrainedProperties as $constrainedProperty) {
            $propertyMetadata = $metadata->getPropertyMetadata($constrainedProperty);
            $constraints = $propertyMetadata[0]->constraints;
            $outputConstraintsCollection = [];
            foreach($constraints as $constraint) {
                $class = new \ReflectionObject($constraint);
                $constraintName = $class->getShortName();
                $constraintParameter = null;
                switch ($constraintName) {
                    case "NotBlank":
                        $param = "notBlank";
                        break;
                    case "Type":
                        $param = $constraint->type;
                        break;
                    case "Length":
                        $param = [
                            'min' => $constraint->min,
                            'max' => $constraint->max
                        ];
                        break;
                }
                $outputConstraintsCollection[$constraintName] = $param;
            }
            $validations[$constrainedProperty] = $outputConstraintsCollection;
        }

        return $validations;
    }
}
